import sys
import json
from PyQt5.QtWidgets import (
    QApplication, QWidget, QVBoxLayout, QPushButton, QLabel, QCheckBox,
    QMessageBox, QDialog, QHBoxLayout, QGroupBox, QListWidget, QListWidgetItem,
    QLineEdit, QInputDialog
)
from PyQt5.QtCore import Qt

from schedule_widget import ScheduleGridWidget

# Update paths as needed
APP_DIR = "/home/atli/Desktop/Block_python"
CLEAN_FILE = f"{APP_DIR}/hosts/hosts.clean"       # Whitelist host file
BLOCKED_FILE = f"{APP_DIR}/hosts/hosts.blocked"   # Blacklist host file
SETTINGS_FILE = "settings.json"


def parse_hosts_file(file_path):
    domains = set()
    try:
        with open(file_path, "r") as f:
            for line in f:
                line = line.strip()
                if not line or line.startswith("#"):
                    continue
                parts = line.split()
                if len(parts) == 2 and parts[0] == "127.0.0.1":
                    dom = parts[1]
                    if dom.startswith("www."):
                        dom = dom[4:]
                    domains.add(dom)
    except FileNotFoundError:
        pass
    return sorted(domains)


def write_hosts_file(file_path, domain_list):
    with open(file_path, "w") as f:
        f.write("# Generated by Focus Blocker\n")
        for d in domain_list:
            d = d.strip()
            if d:
                f.write(f"127.0.0.1 {d}\n")
                f.write(f"127.0.0.1 www.{d}\n")


class SiteListManagerDialog(QDialog):
    # (SiteListManagerDialog remains unchanged from previous version.)
    def __init__(self, file_path, title, other_domains=None, parent=None):
        super().__init__(parent)
        self.setWindowTitle(title)
        self.file_path = file_path
        self.domains = parse_hosts_file(self.file_path)
        self.other_domains = other_domains or []

        main_layout = QVBoxLayout(self)

        self.list_widget = QListWidget()
        main_layout.addWidget(self.list_widget)

        for d in self.domains:
            self.list_widget.addItem(d)

        button_row = QHBoxLayout()
        self.add_button = QPushButton("Add")
        self.remove_button = QPushButton("Remove")
        button_row.addWidget(self.add_button)
        button_row.addWidget(self.remove_button)
        main_layout.addLayout(button_row)

        bottom_row = QHBoxLayout()
        self.save_button = QPushButton("Save")
        self.cancel_button = QPushButton("Cancel")
        bottom_row.addWidget(self.save_button)
        bottom_row.addWidget(self.cancel_button)
        main_layout.addLayout(bottom_row)

        self.add_button.clicked.connect(self.add_domain)
        self.remove_button.clicked.connect(self.remove_domain)
        self.save_button.clicked.connect(self.save_changes)
        self.cancel_button.clicked.connect(self.reject)
        self.list_widget.itemSelectionChanged.connect(self.update_remove_button_state)
        self.update_remove_button_state()

    def update_remove_button_state(self):
        self.remove_button.setEnabled(bool(self.list_widget.selectedItems()))

    def add_domain(self):
        text, ok = QInputDialog.getText(self, "Add Domain", "Enter domain (e.g. 'visir.is'):")
        if ok and text.strip():
            domain = text.strip().lower()
            items = [self.list_widget.item(i).text() for i in range(self.list_widget.count())]
            if domain in items:
                QMessageBox.information(self, "Duplicate", f"'{domain}' is already in this list.")
                return
            if domain in self.other_domains:
                QMessageBox.information(self, "Conflict", f"'{domain}' already appears in the other list. Remove it from there first.")
                return
            self.list_widget.addItem(domain)

    def remove_domain(self):
        for item in self.list_widget.selectedItems():
            self.list_widget.takeItem(self.list_widget.row(item))

    def save_changes(self):
        new_domains = []
        for i in range(self.list_widget.count()):
            new_domains.append(self.list_widget.item(i).text())
        try:
            write_hosts_file(self.file_path, new_domains)
            self.accept()
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to save file: {str(e)}")


from PyQt5.QtWidgets import QDialog, QVBoxLayout, QHBoxLayout, QLabel, QPushButton, QMessageBox
from PyQt5.QtGui import QPixmap
from PyQt5.QtCore import Qt

class DetailedScheduleDialog(QDialog):
    def __init__(self, schedule, mode):
        super().__init__()
        self.setWindowTitle("Detailed Schedule")
        self.schedule = schedule  # The schedule dict for the active mode.
        self.mode = mode

        layout = QVBoxLayout()

        # Add a description at the top explaining the current mode.
        self.info_label = QLabel()
        if self.mode == "whitelist":
            self.info_label.setText(
                "Whitelist Mode:\nBlocks nothing except the pages specified in the whitelist.\n"
                "Only the pages in the whitelist will be allowed."
            )
        else:
            self.info_label.setText(
                "Blacklist Mode:\nBlocks everything except the pages specified in the blacklist.\n"
                "Only the pages in the blacklist will be blocked."
            )
        layout.addWidget(self.info_label)

        # The schedule grid
        self.grid = ScheduleGridWidget(mode=self.mode)
        self.grid.set_schedule(self.schedule)
        layout.addWidget(self.grid)

        # Add a descriptive area below the grid explaining the cell selections.
        desc_layout = QHBoxLayout()
        
        # Full square indicator
        full_label = QLabel()
        full_pixmap = QPixmap("icons/full.png")  # Change path if needed
        if not full_pixmap.isNull():
            full_label.setPixmap(full_pixmap.scaled(20, 20, Qt.KeepAspectRatio, Qt.SmoothTransformation))
        else:
            full_label.setText("[Full]")
        desc_layout.addWidget(full_label)
        desc_layout.addWidget(QLabel(" = 1 hour   "))

        # Half square indicator
        half_label = QLabel()
        half_pixmap = QPixmap("icons/half.png")  # Change path if needed
        if not half_pixmap.isNull():
            half_label.setPixmap(half_pixmap.scaled(20, 20, Qt.KeepAspectRatio, Qt.SmoothTransformation))
        else:
            half_label.setText("[Half]")
        desc_layout.addWidget(half_label)
        desc_layout.addWidget(QLabel(" = 30 minutes"))

        # Center the description layout
        desc_layout.setAlignment(Qt.AlignCenter)
        layout.addLayout(desc_layout)

        # Buttons row (Clear, Save, Cancel)
        button_row = QHBoxLayout()
        clear_btn = QPushButton("Clear")
        clear_btn.clicked.connect(self.clear_schedule)
        button_row.addWidget(clear_btn)

        save_btn = QPushButton("Save")
        cancel_btn = QPushButton("Cancel")
        save_btn.clicked.connect(self.accept)
        cancel_btn.clicked.connect(self.reject)
        button_row.addWidget(save_btn)
        button_row.addWidget(cancel_btn)

        layout.addLayout(button_row)
        self.setLayout(layout)

    def clear_schedule(self):
        reply = QMessageBox.warning(
            self,
            "Clear Schedule",
            "Are you sure you want to clear everything?",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No
        )
        if reply == QMessageBox.Yes:
            self.grid.clear_all()

    def get_updated_schedule(self):
        return self.grid.get_schedule()




class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Focus Blocker Settings")
        self.setFixedSize(600, 400)
        self.load_settings()

        main_layout = QVBoxLayout()

        # 1) Mode switch at top
        self.mode_button = QPushButton(
            f"Switch to {'Whitelist' if self.mode == 'blacklist' else 'Blacklist'} Mode"
        )
        self.mode_button.clicked.connect(self.toggle_mode)
        main_layout.addWidget(self.mode_button)

        # 2) Site Lists group in the middle
        sites_group = QGroupBox("Site Lists")
        sites_layout = QHBoxLayout()
        sites_layout.addStretch()
        self.whitelist_button = QPushButton("Edit Whitelist Sites")
        self.whitelist_button.setFixedSize(150, 40)
        self.blacklist_button = QPushButton("Edit Blacklist Sites")
        self.blacklist_button.setFixedSize(150, 40)
        self.whitelist_button.clicked.connect(self.edit_whitelist)
        self.blacklist_button.clicked.connect(self.edit_blacklist)
        sites_layout.addWidget(self.whitelist_button)
        sites_layout.addWidget(self.blacklist_button)
        sites_layout.addStretch()
        sites_group.setLayout(sites_layout)
        main_layout.addWidget(sites_group)

        # 3) Schedule group at bottom
        schedule_group = QGroupBox("Schedule")
        schedule_layout = QVBoxLayout()
        explanation_label = QLabel("Use the schedule to automatically block distractions at specific times.")
        schedule_layout.addWidget(explanation_label)
        self.enable_schedule = QCheckBox("Enable schedule blocking")
        self.enable_schedule.setChecked(self.schedule_enabled)
        schedule_layout.addWidget(self.enable_schedule)
        self.detailed_button = QPushButton("Edit Detailed Schedule")
        schedule_layout.addWidget(self.detailed_button)
        self.detailed_button.clicked.connect(self.open_detailed_schedule)
        schedule_group.setLayout(schedule_layout)
        main_layout.addWidget(schedule_group)

        self.setLayout(main_layout)

    def load_settings(self):
        try:
            with open(SETTINGS_FILE, "r") as f:
                data = json.load(f)
        except FileNotFoundError:
            data = {}
        # Retrieve mode and schedule_enabled directly.
        self.mode = data.get("mode", "blacklist")
        self.schedule_enabled = data.get("schedule_enabled", False)
        # Now, schedule_data is stored per mode:
        # For example: {"blacklist": { ... }, "whitelist": { ... }}
        self.schedule_data = data.get("schedule_data", {})

    def save_settings(self):
        data = {
            "mode": self.mode,
            "schedule_enabled": self.enable_schedule.isChecked(),
            "schedule_data": self.schedule_data  # this is a dictionary keyed by mode
        }
        with open(SETTINGS_FILE, "w") as f:
            json.dump(data, f, indent=4)

    def toggle_mode(self):
        self.mode = "whitelist" if self.mode == "blacklist" else "blacklist"
        self.mode_button.setText(
            f"Switch to {'Whitelist' if self.mode == 'blacklist' else 'Blacklist'} Mode"
        )
        self.save_settings()

    def open_detailed_schedule(self):
        # Get schedule for current mode, or an empty dictionary if none saved yet.
        schedule = self.schedule_data.get(self.mode, {})
        dialog = DetailedScheduleDialog(schedule, self.mode)
        if dialog.exec_() == QDialog.Accepted:
            # Save the updated schedule into the correct mode slot.
            self.schedule_data[self.mode] = dialog.get_updated_schedule()
            self.save_settings()
            QMessageBox.information(self, "Saved", "Schedule updated successfully.")

    def edit_whitelist(self):
        # Pass blacklist domains to prevent duplicates
        other_domains = parse_hosts_file(BLOCKED_FILE)
        dialog = SiteListManagerDialog(CLEAN_FILE, "Edit Whitelist Sites", other_domains, self)
        if dialog.exec_() == QDialog.Accepted:
            QMessageBox.information(self, "Saved", "Whitelist updated successfully.")

    def edit_blacklist(self):
        other_domains = parse_hosts_file(CLEAN_FILE)
        dialog = SiteListManagerDialog(BLOCKED_FILE, "Edit Blacklist Sites", other_domains, self)
        if dialog.exec_() == QDialog.Accepted:
            QMessageBox.information(self, "Saved", "Blacklist updated successfully.")


if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = MainWindow()
    window.show()
    sys.exit(app.exec_())
